
.. code:: python

    %matplotlib inline
    
    import numpy as np
    import scipy as sp
    import matplotlib.pyplot as plt
    Lg = np.polynomial.Legendre
    lg = np.polynomial.legendre
We want to represent the microstructure function in terms of a series of
basis functions. In this case we are going to go with the Legendre
polynomials.

.. math::  m_s(h) = \sum_{l = 0}^\infty c_{ls} P_l (h) 

The coefficients of this series can be found with the following equation

.. math::   c_{ls} = (2l +1) \int_{-1}^1 P_l (h) m_s(h) 

If in location :math:`s` there is only one value of concentration rather
than a distribution of states the microstructure function is a delta
function.

.. math::  m_s(h) = \delta_s(h - h0) 

Therefore

.. math::   c_{ls} = (2l +1) \int_{-1}^1 P_l (h) \delta_s(h - h0) 

.. math::   c_{ls} = (2l +1)  P_l (h0) 

Let's find the first 4 coefficients for :math:`h0 = 0.25`

.. code:: python

    n_coeffs = 4
    h0 = 0.25
    
    coeff = np.zeros(n_coeffs)
    for ii in range(n_coeffs):
        P = Lg.basis(ii)
        coeff[ii] = (2 * ii + 1) * P(h0)
        
    print coeff
        
        
        

.. parsed-literal::

    [ 1.         0.75      -2.03125   -2.3515625]


Here is some thoughts on doing it without loops.

.. code:: python

    def eval_h0(h0, basis, order, norm):
        basis = basis.basis(order)
        return norm(order) * basis(h0)
    
    def _get_basis(basis, order, norm):
        basis_array = []
        for ii in range(order):
            basis_array.append(norm(ii) * basis.basis(ii))
        return np.array(basis_array)
            
    def Legendre_norm(n):
        return 2 * n + 1
    
    def _get_states_array(X_shape, n_states):
        return np.ones((X_shape) + (n_states,)) * np.arange(n_states)

.. code:: python

    eval_h0_vect = np.vectorize(np.vectorize(eval_h0))
.. code:: python

    X = np.array([[0.25, 0.1], [0.5, 0.25]])
    
    lg.legval
    norm = np.eye(3) * ( 2 * np.arange(3) + 1)
    print norm
    #weights = 2 * np.arange(3) + 1
    #print ieys * weights
    print lg.legval(X, norm, domain=).T

.. parsed-literal::

    [[-0.5 -0.8]
     [ 0.  -0.5]]
    [[ 1.  0.  0.]
     [ 0.  3.  0.]
     [ 0.  0.  5.]]
    (2, 2, 3)


.. code:: python

    np.random.seed(99)
    X = np.random.random((1, 2, 3))
    from pymks.basis import Legendre
    X_Legendre = Legendre(X, 2, [0, 1])
    
    print X.shape
    print X_Legendre.shape
    print np.rollaxis(X_Legendre, 0, len(X_Legendre.shape)).shape
    print np.flipud(X_Legendre[...,])
    #print X
    #print X_Legendre

.. parsed-literal::

    (1, 2, 3)
    (3, 2, 1, 2)
    (2, 1, 2, 3)


::


    ---------------------------------------------------------------------------
    AttributeError                            Traceback (most recent call last)

    <ipython-input-68-3b72d3986331> in <module>()
          7 print X_Legendre.shape
          8 print np.rollaxis(X_Legendre, 0, len(X_Legendre.shape)).shape
    ----> 9 print np.flip(up)
         10 #print X
         11 #print X_Legendre


    AttributeError: 'module' object has no attribute 'flip'


.. code:: python

    import pymks
    from pymks.datasets import make_cahnHilliard
    
    L = 21
    n_samples = 400
    
    np.random.seed(99)
    X, y = make_cahnHilliard(n_samples=n_samples, size=(L, L))
.. code:: python

    from pymks.basis import Legendre_fft
    Q = Legendre_fft(X, 3, [0, 1])
.. code:: python

    from pymks.tools import draw_concentrations
    
    draw_concentrations(X[0], y[0])

.. parsed-literal::

    /home/david/anaconda/lib/python2.7/site-packages/matplotlib/figure.py:1595: UserWarning: This figure includes Axes that are not compatible with tight_layout, so its results might be incorrect.
      warnings.warn("This figure includes Axes that are not "



.. image:: Polynomials_files/Polynomials_10_1.png


.. code:: python

    from pymks.tools import optimize_n_states
    
    n_states_values = np.arange(2, 21)
    optm_n_states = optimize_n_states(n_states_values=n_states_values, X=X, y=y, plot=True)
.. code:: python

    A = np.arange(12).reshape(3, 2, 2)
    print A
    #print A[..., 0]
    #print np.flipud(A[..., 0])
    print np.fliplr(A)
    print np.flipud(A)
    print np.rollaxis(np.flipud(A), 0, len(A.shape))

.. parsed-literal::

    [[[ 0  1]
      [ 2  3]]
    
     [[ 4  5]
      [ 6  7]]
    
     [[ 8  9]
      [10 11]]]
    [[[ 2  3]
      [ 0  1]]
    
     [[ 6  7]
      [ 4  5]]
    
     [[10 11]
      [ 8  9]]]
    [[[ 8  9]
      [10 11]]
    
     [[ 4  5]
      [ 6  7]]
    
     [[ 0  1]
      [ 2  3]]]
    [[[ 8  4  0]
      [ 9  5  1]]
    
     [[10  6  2]
      [11  7  3]]]


.. code:: python

    import numpy as np
    from pymks.basis import Chebyshev
    X = np.array([[0.25, 0.], [0., 0.25]])
    
    Chebyshev(X, 3, [0, 1])

.. parsed-literal::

    [[ 0.31830989  0.          0.        ]
     [ 0.          0.63661977  0.        ]
     [ 0.          0.          0.63661977]]


.. parsed-literal::

    /home/david/anaconda/lib/python2.7/site-packages/numpy/polynomial/chebyshev.py:1937: RuntimeWarning: divide by zero encountered in true_divide
      w = 1./(np.sqrt(1. + x) * np.sqrt(1. - x))
    /home/david/anaconda/lib/python2.7/site-packages/numpy/polynomial/chebyshev.py:1179: RuntimeWarning: invalid value encountered in multiply
      c1 = tmp + c1*x2




.. parsed-literal::

    array([[[-0.21220659, -0.3675526 ,  0.31830989],
            [        inf,         nan,         nan]],
    
           [[        inf,         nan,         nan],
            [-0.21220659, -0.3675526 ,  0.31830989]]])



.. code:: python

    cheb = np.polynomial.chebyshev 
    cheb.chebval(1., np.eye(4))
    cheb.chebweight(0.)



.. parsed-literal::

    1.0



.. code:: python

    import scipy as sp
.. code:: python

    X = np.array([[0.25, 0.], [1., 0.25]])
    print np.arange(4) * np.eye(4)
    np.flipud(sp.special.eval_chebyu(np.arange(2), X))
    sp.special.eval_chebyu(X, np.arange(4))

.. parsed-literal::

    [[ 0.  0.  0.  0.]
     [ 0.  1.  0.  0.]
     [ 0.  0.  2.  0.]
     [ 0.  0.  0.  3.]]


::


    ---------------------------------------------------------------------------
    ValueError                                Traceback (most recent call last)

    <ipython-input-14-2977541692a3> in <module>()
          2 print np.arange(4) * np.eye(4)
          3 np.flipud(sp.special.eval_chebyu(np.arange(2), X))
    ----> 4 sp.special.eval_chebyu(X, np.arange(4))
    

    ValueError: operands could not be broadcast together with shapes (2,2) (4,) 


.. code:: python

    herm = np.polynomial.hermite
    X_weight = herm.hermweight(X).repeat(3, axis=1).reshape(2, 2, 3)
    n = np.arange(3)
    norm = (np.sqrt(np.pi) * sp.misc.factorial(n) * 2 ** n) ** -1
    print X
    print norm 
    print X_weight

.. parsed-literal::

    [[ 0.25  0.  ]
     [ 1.    0.25]]
    [ 0.56418958  0.28209479  0.0705237 ]
    [[[ 0.93941306  0.93941306  0.93941306]
      [ 1.          1.          1.        ]]
    
     [[ 0.36787944  0.36787944  0.36787944]
      [ 0.93941306  0.93941306  0.93941306]]]


.. code:: python

    X_Hermite = np.flipud(herm.hermval(X, np.eye(3) * norm))
    print np.rollaxis(X_Hermite, 0 , len(X_Hermite.shape)) * X_weight
    


.. parsed-literal::

    [[[-0.11593905  0.13250177  0.53000706]
      [-0.1410474   0.          0.56418958]]
    
     [[ 0.05188844  0.20755375  0.20755375]
      [-0.11593905  0.13250177  0.53000706]]]


.. code:: python

    import numpy as np
    from pymks.basis import Hermite
    
    X = np.array([[0.25, 0.], [1., 0.25]]) 
    Hermite(X, 3, domain=[0, 1])



.. parsed-literal::

    array([[[-0.11593905,  0.13250177,  0.53000706],
            [-0.1410474 ,  0.        ,  0.56418958]],
    
           [[ 0.05188844,  0.20755375,  0.20755375],
            [-0.11593905,  0.13250177,  0.53000706]]])



.. code:: python

    from pymks.basis import Legendre
    Xleg = np.array([[0.25, 0.1], [0.5, 0.25]])
    Legendre(Xleg, 3, domain=[0, 1])



.. parsed-literal::

    array([[[-0.3125, -0.75  ,  0.5   ],
            [ 1.15  , -1.2   ,  0.5   ]],
    
           [[-1.25  ,  0.    ,  0.5   ],
            [-0.3125, -0.75  ,  0.5   ]]])



.. code:: python

    from pymks.basis import Hermite
.. code:: python

    import numpy as np
    Hermite(np.array([[1, 0], [0, 1]]), deg=4)



.. parsed-literal::

    array([[[-0.01729615,  0.05188844,  0.20755375,  0.20755375],
            [ 0.        , -0.1410474 ,  0.        ,  0.56418958]],
    
           [[ 0.        , -0.1410474 ,  0.        ,  0.56418958],
            [-0.01729615,  0.05188844,  0.20755375,  0.20755375]]])



.. code:: python

    from pymks.microstructureFunction import MicrostructureFunction
    

.. code:: python

    n_states = 2
    np.random.seed(3)
    X = np.random.random((1, 3, 3))
    FX_ = MicrostructureFunction(n_states)._Legendre_fft(X, n_states, [0, 1])
    print FX_
    X_ = np.fft.ifftn(FX_, axes=(1, 2))
    H = np.linspace(0, 1, n_states)
    


.. parsed-literal::

    [[[[ 3.70264051+0.j         -5.29735949+0.j        ]
       [-1.00887157-1.48005289j -1.00887157-1.48005289j]
       [-1.00887157+1.48005289j -1.00887157+1.48005289j]]
    
      [[ 0.62300683-4.97732233j  0.62300683-4.97732233j]
       [ 1.09318216+0.10131035j  1.09318216+0.10131035j]
       [ 0.37713401+1.87334545j  0.37713401+1.87334545j]]
    
      [[ 0.62300683+4.97732233j  0.62300683+4.97732233j]
       [ 0.37713401-1.87334545j  0.37713401-1.87334545j]
       [ 1.09318216-0.10131035j  1.09318216-0.10131035j]]]]


