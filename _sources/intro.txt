
Introduction
------------

An important component of the MKS is the regression technique for rapid
calculation of a response feild :math:`p_i` based on a microstructure
:math:`m_i`, where the index :math:`i` refers to a spatial location
often in 2D or 3D. For example, the microstructure might represent
values of material properties that vary based on phase such as elastic
modulus or Poisson's ratio while the response might be the stress or
strain field.

Discretize in State Space
-------------------------

The first step in the MKS is to bin (or discretize) the state space. To
so this, the microstructure :math:`m_i` and is discretized and then
represented by :math:`m^h_i` such that

.. math::  m_i = \sum_h m_{i,h} \chi_h 

where :math:`\chi_h` is the basis representation for the microstructure.

The following images represent simplest form of discretization. State
space discrtization is analogous to splitting the data into channels in
signal processing. For example, a value of 0.049 is represented by
(0.76, 0.24, 0, 0, 0, 0) when discretized into 6 bins sampled over an
interval of 0 to 1.

.. code:: python

    from IPython.display import Image
    Image(filename='microstructure.png')



.. image:: intro_files/intro_1_0.png



The Influence Coefficients
--------------------------

Once the state space is discretized, the relationship between the
response :math:`p_i` and microstructure :math:`m_i^h` can be written as,

.. math::  p_i = \sum_h \sum_j \alpha_{j,h} m_{i + j,h} 

where the :math:`\alpha_{j,h}` are known as the influence coefficients
and describe the relationship between :math:`p_i` and :math:`m_j`. The
:math:`p_i` are a spatial convolution of :math:`\alpha_{j,h}` and
:math:`m_j`. In general, it is assumed that both :math:`m_j` and
:math:`p_i` are periodic.

\*\*\* Note that the formulation above has dropped an index representing
the samples for simplicity. Generally the MKS is calibrated using many
samples. \*\*\*

The Convolution
---------------

The efficiency of the MKS is due to solving the linear regression in
Fourier space. For a 2D problem of size :math:`N^2`, the size of the
regression is reduced from $ (N^2 N\_{} N^2 H )$ to
:math:`\left(N_{\text{sample}} \times H \right)` for each point in the
Fourier space of size :math:`N^2`. The convolution,

.. math::  \sum_h \sum_j \alpha_j^h m_{i + j}^h 

can be deconvolved in Fourier space using `circular convolution
theorem <http://en.wikipedia.org/wiki/Discrete_Fourier_transform#Circular_convolution_theorem_and_cross-correlation_theorem>`__

If we write :math:`P_{k} =  \mathcal{F}_k \left( p_{s} \right)`,
:math:`M_{k}^h = \mathcal{F}_k  \left( m_{s}^h \right)` and
:math:`\beta_k^h = \mathcal{F}_k \left(  \alpha_s^h \right)`, then we
just need to solve

.. math::  P_{k} = \sum\limits_{h=0}^{h-1} \beta_k^h M_{k}^h 

with a linear regression at each discretization location in :math:`k` to
calculate the :math:`\beta_k^h`.

PyMKS Example
-------------

One important application of the MKS is to accurately and rapidly
reproduce finite element simulations based on microstructure. Let's
start by running a finite element simulation on a random microstructure
with different elastic moduli. The ``ElasticFEModel`` class encapsulates
the code needed to run a plain strain problem using SfePy. It solves a
plain strain problem on a square domain by straining in the x-direction
and applying periodic boundary conditions in the y-direction. The two
phase microstructure is represented by ``X`` with one phase having an
elastic modulus of 80 and the other a value of 120.

.. code:: python

    from pymks import ElasticFEModel
    from pymks.tools import draw_microstructure_strain
    from mpl_toolkits.axes_grid1 import make_axes_locatable
    
    E1 = 80 
    E2 = 120 
    nu = 0.3 
    
    N = 15
    np.random.seed(21)
    X = np.random.randint(2, size=(1, N, N))
    X_prop = np.zeros((X.shape + (2,)))
    X_prop[...,0] = np.where(X == 0, E1, E2)
    X_prop[...,1] = nu
    
    FEModel = ElasticFEModel()
    strains = FEModel.predict(X_prop)
    
    draw_microstructure_strain(X[0], strains[0,...,0])
    


.. parsed-literal::

    /home/wd15/anaconda/lib/python2.7/site-packages/matplotlib/figure.py:1595: UserWarning: This figure includes Axes that are not compatible with tight_layout, so its results might be incorrect.
      warnings.warn("This figure includes Axes that are not "



.. image:: intro_files/intro_5_1.png


Create the Delta Microstructures
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The goal of the MKS it to reproduce the above simulation. In the case of
linear elasticity the MKS model can be seeded with a delta
microstructure. The following code snippet creates a delta
microstructure with two samples.

.. code:: python

    from pymks.tools import draw_microstructures
    
    N = 15
    X_delta = np.zeros((2, N, N))
    X_delta[0, (N - 1) / 2, (N - 1) / 2] = 1
    X_delta[1] = np.abs(X_delta[0] - 1)
    
    draw_microstructures(X_delta[0], X_delta[1])


.. image:: intro_files/intro_7_0.png


Create the Responses
~~~~~~~~~~~~~~~~~~~~

We now create the responses from the microstructure using the
``ElasticFEModel``.

.. code:: python

    X_delta_prop = np.zeros((X_delta.shape + (2,)))
    X_delta_prop[...,0] = np.where(X_delta == 0, E1, E2)
    X_delta_prop[...,1] = nu
    
    FEModel = ElasticFEModel()
    strains_delta = FEModel.predict(X_delta_prop)
    
    draw_microstructure_strain(X_delta[0], strains_delta[0,...,0])



.. image:: intro_files/intro_9_0.png


Calibrate the MKS Model
~~~~~~~~~~~~~~~~~~~~~~~

The ``fit`` method from the ``MKSRegressionModel`` is used to calibrate
the coefficients.

.. code:: python

    from pymks import MKSRegressionModel
    
    X_delta, y_delta = X_delta, strains_delta[...,0]
    model = MKSRegressionModel(Nbin=2)
    model.fit(X_delta, y_delta)
Predict the FE Simulation
~~~~~~~~~~~~~~~~~~~~~~~~~

When the ``model`` is calibrated it stores the influence coefficients,
which are then be used by the ``predict`` method to return the predicted
strains.

.. code:: python

    from pymks.tools import draw_strains
    
    X, y = X, strains[...,0]
    y_pred = model.predict(X)
    draw_strains(y[0], y_pred[0]);


.. image:: intro_files/intro_13_0.png


The MKS has done quite a good job of predicting the results from the
original FE simulation using only the delta microstructue to calibrate
the influence coefficients.

Comments
~~~~~~~~

The MKS coefficients can then be scaled up to reproduce larger FE
simulations using only the small FE simulation to seed the MKS model.

\*\* Note that the cells close to the left and right side of the domain
are not well predicited. This is due to issues with the SfePy FE solver
and periodic boundary conditions. This should be ironed out soon. \*\*
